/* automatically generated by rust-bindgen */

#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::const_static_lifetime)]
#![allow(clippy::unreadable_literal)]
#![allow(clippy::cyclomatic_complexity)]

pub const NETLINK_ROUTE: u32 = 0;
pub const NETLINK_UNUSED: u32 = 1;
pub const NETLINK_USERSOCK: u32 = 2;
pub const NETLINK_FIREWALL: u32 = 3;
pub const NETLINK_SOCK_DIAG: u32 = 4;
pub const NETLINK_NFLOG: u32 = 5;
pub const NETLINK_XFRM: u32 = 6;
pub const NETLINK_SELINUX: u32 = 7;
pub const NETLINK_ISCSI: u32 = 8;
pub const NETLINK_AUDIT: u32 = 9;
pub const NETLINK_FIB_LOOKUP: u32 = 10;
pub const NETLINK_CONNECTOR: u32 = 11;
pub const NETLINK_NETFILTER: u32 = 12;
pub const NETLINK_IP6_FW: u32 = 13;
pub const NETLINK_DNRTMSG: u32 = 14;
pub const NETLINK_KOBJECT_UEVENT: u32 = 15;
pub const NETLINK_GENERIC: u32 = 16;
pub const NETLINK_SCSITRANSPORT: u32 = 18;
pub const NETLINK_ECRYPTFS: u32 = 19;
pub const NETLINK_RDMA: u32 = 20;
pub const NETLINK_CRYPTO: u32 = 21;
pub const NETLINK_SMC: u32 = 22;
pub const NETLINK_INET_DIAG: u32 = 4;
pub const NLM_F_REQUEST: u32 = 1;
pub const NLM_F_MULTI: u32 = 2;
pub const NLM_F_ACK: u32 = 4;
pub const NLM_F_ECHO: u32 = 8;
pub const NLM_F_DUMP_INTR: u32 = 16;
pub const NLM_F_DUMP_FILTERED: u32 = 32;
pub const NLM_F_ROOT: u32 = 256;
pub const NLM_F_MATCH: u32 = 512;
pub const NLM_F_ATOMIC: u32 = 1024;
pub const NLM_F_DUMP: u32 = 768;
pub const NLM_F_REPLACE: u32 = 256;
pub const NLM_F_EXCL: u32 = 512;
pub const NLM_F_CREATE: u32 = 1024;
pub const NLM_F_APPEND: u32 = 2048;
pub const NLM_F_NONREC: u32 = 256;
pub const NLM_F_CAPPED: u32 = 256;
pub const NLM_F_ACK_TLVS: u32 = 512;
pub const NLMSG_ALIGNTO: u32 = 4;
pub const NLMSG_NOOP: u32 = 1;
pub const NLMSG_ERROR: u32 = 2;
pub const NLMSG_DONE: u32 = 3;
pub const NLMSG_OVERRUN: u32 = 4;
pub const NLMSG_MIN_TYPE: u32 = 16;
pub const NETLINK_ADD_MEMBERSHIP: u32 = 1;
pub const NETLINK_DROP_MEMBERSHIP: u32 = 2;
pub const NETLINK_PKTINFO: u32 = 3;
pub const NETLINK_BROADCAST_ERROR: u32 = 4;
pub const NETLINK_NO_ENOBUFS: u32 = 5;
pub const NETLINK_RX_RING: u32 = 6;
pub const NETLINK_TX_RING: u32 = 7;
pub const NETLINK_LISTEN_ALL_NSID: u32 = 8;
pub const NETLINK_LIST_MEMBERSHIPS: u32 = 9;
pub const NETLINK_CAP_ACK: u32 = 10;
pub const NETLINK_EXT_ACK: u32 = 11;
pub const NL_MMAP_MSG_ALIGNMENT: u32 = 4;
pub const NLA_F_NESTED: u32 = 32768;
pub const NLA_F_NET_BYTEORDER: u32 = 16384;
pub const NLA_TYPE_MASK: i32 = -49153;
pub const NLA_ALIGNTO: u32 = 4;
pub const LIBNL_STRING: &'static [u8; 12usize] = b"libnl 3.4.0\0";
pub const LIBNL_VERSION: &'static [u8; 6usize] = b"3.4.0\0";
pub const LIBNL_VER_MAJ: u32 = 3;
pub const LIBNL_VER_MIN: u32 = 4;
pub const LIBNL_VER_MIC: u32 = 0;
pub const LIBNL_CURRENT: u32 = 226;
pub const LIBNL_REVISION: u32 = 0;
pub const LIBNL_AGE: u32 = 26;
pub const NLE_SUCCESS: u32 = 0;
pub const NLE_FAILURE: u32 = 1;
pub const NLE_INTR: u32 = 2;
pub const NLE_BAD_SOCK: u32 = 3;
pub const NLE_AGAIN: u32 = 4;
pub const NLE_NOMEM: u32 = 5;
pub const NLE_EXIST: u32 = 6;
pub const NLE_INVAL: u32 = 7;
pub const NLE_RANGE: u32 = 8;
pub const NLE_MSGSIZE: u32 = 9;
pub const NLE_OPNOTSUPP: u32 = 10;
pub const NLE_AF_NOSUPPORT: u32 = 11;
pub const NLE_OBJ_NOTFOUND: u32 = 12;
pub const NLE_NOATTR: u32 = 13;
pub const NLE_MISSING_ATTR: u32 = 14;
pub const NLE_AF_MISMATCH: u32 = 15;
pub const NLE_SEQ_MISMATCH: u32 = 16;
pub const NLE_MSG_OVERFLOW: u32 = 17;
pub const NLE_MSG_TRUNC: u32 = 18;
pub const NLE_NOADDR: u32 = 19;
pub const NLE_SRCRT_NOSUPPORT: u32 = 20;
pub const NLE_MSG_TOOSHORT: u32 = 21;
pub const NLE_MSGTYPE_NOSUPPORT: u32 = 22;
pub const NLE_OBJ_MISMATCH: u32 = 23;
pub const NLE_NOCACHE: u32 = 24;
pub const NLE_BUSY: u32 = 25;
pub const NLE_PROTO_MISMATCH: u32 = 26;
pub const NLE_NOACCESS: u32 = 27;
pub const NLE_PERM: u32 = 28;
pub const NLE_PKTLOC_FILE: u32 = 29;
pub const NLE_PARSE_ERR: u32 = 30;
pub const NLE_NODEV: u32 = 31;
pub const NLE_IMMUTABLE: u32 = 32;
pub const NLE_DUMP_INTR: u32 = 33;
pub const NLE_ATTRSIZE: u32 = 34;
pub const NLE_MAX: u32 = 34;
pub const NL_PROB_MIN: u32 = 0;
pub const NL_PROB_MAX: u32 = 4294967295;
pub const NL_DONTPAD: u32 = 0;
pub const NL_AUTO_PORT: u32 = 0;
pub const NL_AUTO_PID: u32 = 0;
pub const NL_AUTO_SEQ: u32 = 0;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
  _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
  pub _flags: ::std::os::raw::c_int,
  pub _IO_read_ptr: *mut ::std::os::raw::c_char,
  pub _IO_read_end: *mut ::std::os::raw::c_char,
  pub _IO_read_base: *mut ::std::os::raw::c_char,
  pub _IO_write_base: *mut ::std::os::raw::c_char,
  pub _IO_write_ptr: *mut ::std::os::raw::c_char,
  pub _IO_write_end: *mut ::std::os::raw::c_char,
  pub _IO_buf_base: *mut ::std::os::raw::c_char,
  pub _IO_buf_end: *mut ::std::os::raw::c_char,
  pub _IO_save_base: *mut ::std::os::raw::c_char,
  pub _IO_backup_base: *mut ::std::os::raw::c_char,
  pub _IO_save_end: *mut ::std::os::raw::c_char,
  pub _markers: *mut _IO_marker,
  pub _chain: *mut _IO_FILE,
  pub _fileno: ::std::os::raw::c_int,
  pub _flags2: ::std::os::raw::c_int,
  pub _old_offset: __off_t,
  pub _cur_column: ::std::os::raw::c_ushort,
  pub _vtable_offset: ::std::os::raw::c_schar,
  pub _shortbuf: [::std::os::raw::c_char; 1usize],
  pub _lock: *mut _IO_lock_t,
  pub _offset: __off64_t,
  pub _codecvt: *mut _IO_codecvt,
  pub _wide_data: *mut _IO_wide_data,
  pub _freeres_list: *mut _IO_FILE,
  pub _freeres_buf: *mut ::std::os::raw::c_void,
  pub __pad5: usize,
  pub _mode: ::std::os::raw::c_int,
  pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
  assert_eq!(
    ::std::mem::size_of::<_IO_FILE>(),
    216usize,
    concat!("Size of: ", stringify!(_IO_FILE))
  );
  assert_eq!(
    ::std::mem::align_of::<_IO_FILE>(),
    8usize,
    concat!("Alignment of ", stringify!(_IO_FILE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_read_ptr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_read_end)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_read_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_write_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_write_ptr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_write_end)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_buf_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_buf_end)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_save_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_backup_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_save_end)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_markers)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_chain)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_fileno)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_flags2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_old_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_cur_column)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
    130usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_vtable_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
    131usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_shortbuf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_lock)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_codecvt)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_wide_data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_freeres_list)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_freeres_buf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(__pad5)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_mode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_unused2)
    )
  );
}
pub type nlink_t = __nlink_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
  pub iov_base: *mut ::std::os::raw::c_void,
  pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
  assert_eq!(
    ::std::mem::size_of::<iovec>(),
    16usize,
    concat!("Size of: ", stringify!(iovec))
  );
  assert_eq!(
    ::std::mem::align_of::<iovec>(),
    8usize,
    concat!("Alignment of ", stringify!(iovec))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(iovec),
      "::",
      stringify!(iov_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(iovec),
      "::",
      stringify!(iov_len)
    )
  );
}
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
  pub sa_family: sa_family_t,
  pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
  assert_eq!(
    ::std::mem::size_of::<sockaddr>(),
    16usize,
    concat!("Size of: ", stringify!(sockaddr))
  );
  assert_eq!(
    ::std::mem::align_of::<sockaddr>(),
    2usize,
    concat!("Alignment of ", stringify!(sockaddr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr),
      "::",
      stringify!(sa_family)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr),
      "::",
      stringify!(sa_data)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
  pub msg_name: *mut ::std::os::raw::c_void,
  pub msg_namelen: socklen_t,
  pub msg_iov: *mut iovec,
  pub msg_iovlen: usize,
  pub msg_control: *mut ::std::os::raw::c_void,
  pub msg_controllen: usize,
  pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
  assert_eq!(
    ::std::mem::size_of::<msghdr>(),
    56usize,
    concat!("Size of: ", stringify!(msghdr))
  );
  assert_eq!(
    ::std::mem::align_of::<msghdr>(),
    8usize,
    concat!("Alignment of ", stringify!(msghdr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(msghdr),
      "::",
      stringify!(msg_name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(msghdr),
      "::",
      stringify!(msg_namelen)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(msghdr),
      "::",
      stringify!(msg_iov)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(msghdr),
      "::",
      stringify!(msg_iovlen)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(msghdr),
      "::",
      stringify!(msg_control)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(msghdr),
      "::",
      stringify!(msg_controllen)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(msghdr),
      "::",
      stringify!(msg_flags)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
  pub ai_flags: ::std::os::raw::c_int,
  pub ai_family: ::std::os::raw::c_int,
  pub ai_socktype: ::std::os::raw::c_int,
  pub ai_protocol: ::std::os::raw::c_int,
  pub ai_addrlen: socklen_t,
  pub ai_addr: *mut sockaddr,
  pub ai_canonname: *mut ::std::os::raw::c_char,
  pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
  assert_eq!(
    ::std::mem::size_of::<addrinfo>(),
    48usize,
    concat!("Size of: ", stringify!(addrinfo))
  );
  assert_eq!(
    ::std::mem::align_of::<addrinfo>(),
    8usize,
    concat!("Alignment of ", stringify!(addrinfo))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(addrinfo),
      "::",
      stringify!(ai_flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_family as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(addrinfo),
      "::",
      stringify!(ai_family)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_socktype as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(addrinfo),
      "::",
      stringify!(ai_socktype)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_protocol as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(addrinfo),
      "::",
      stringify!(ai_protocol)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addrlen as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(addrinfo),
      "::",
      stringify!(ai_addrlen)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addr as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(addrinfo),
      "::",
      stringify!(ai_addr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_canonname as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(addrinfo),
      "::",
      stringify!(ai_canonname)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_next as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(addrinfo),
      "::",
      stringify!(ai_next)
    )
  );
}
pub type __u8 = ::std::os::raw::c_uchar;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __u32 = ::std::os::raw::c_uint;
pub type __kernel_sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_nl {
  pub nl_family: __kernel_sa_family_t,
  pub nl_pad: ::std::os::raw::c_ushort,
  pub nl_pid: __u32,
  pub nl_groups: __u32,
}
#[test]
fn bindgen_test_layout_sockaddr_nl() {
  assert_eq!(
    ::std::mem::size_of::<sockaddr_nl>(),
    12usize,
    concat!("Size of: ", stringify!(sockaddr_nl))
  );
  assert_eq!(
    ::std::mem::align_of::<sockaddr_nl>(),
    4usize,
    concat!("Alignment of ", stringify!(sockaddr_nl))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_family as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_nl),
      "::",
      stringify!(nl_family)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_pad as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_nl),
      "::",
      stringify!(nl_pad)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_pid as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_nl),
      "::",
      stringify!(nl_pid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_groups as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_nl),
      "::",
      stringify!(nl_groups)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlmsghdr {
  pub nlmsg_len: __u32,
  pub nlmsg_type: __u16,
  pub nlmsg_flags: __u16,
  pub nlmsg_seq: __u32,
  pub nlmsg_pid: __u32,
}
#[test]
fn bindgen_test_layout_nlmsghdr() {
  assert_eq!(
    ::std::mem::size_of::<nlmsghdr>(),
    16usize,
    concat!("Size of: ", stringify!(nlmsghdr))
  );
  assert_eq!(
    ::std::mem::align_of::<nlmsghdr>(),
    4usize,
    concat!("Alignment of ", stringify!(nlmsghdr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_len as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(nlmsghdr),
      "::",
      stringify!(nlmsg_len)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_type as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(nlmsghdr),
      "::",
      stringify!(nlmsg_type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_flags as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(nlmsghdr),
      "::",
      stringify!(nlmsg_flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_seq as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(nlmsghdr),
      "::",
      stringify!(nlmsg_seq)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_pid as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(nlmsghdr),
      "::",
      stringify!(nlmsg_pid)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlmsgerr {
  pub error: ::std::os::raw::c_int,
  pub msg: nlmsghdr,
}
#[test]
fn bindgen_test_layout_nlmsgerr() {
  assert_eq!(
    ::std::mem::size_of::<nlmsgerr>(),
    20usize,
    concat!("Size of: ", stringify!(nlmsgerr))
  );
  assert_eq!(
    ::std::mem::align_of::<nlmsgerr>(),
    4usize,
    concat!("Alignment of ", stringify!(nlmsgerr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nlmsgerr>())).error as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(nlmsgerr),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nlmsgerr>())).msg as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(nlmsgerr),
      "::",
      stringify!(msg)
    )
  );
}
pub const nlmsgerr_attrs_NLMSGERR_ATTR_UNUSED: nlmsgerr_attrs = 0;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MSG: nlmsgerr_attrs = 1;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_OFFS: nlmsgerr_attrs = 2;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_COOKIE: nlmsgerr_attrs = 3;
pub const nlmsgerr_attrs___NLMSGERR_ATTR_MAX: nlmsgerr_attrs = 4;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MAX: nlmsgerr_attrs = 3;
pub type nlmsgerr_attrs = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_pktinfo {
  pub group: __u32,
}
#[test]
fn bindgen_test_layout_nl_pktinfo() {
  assert_eq!(
    ::std::mem::size_of::<nl_pktinfo>(),
    4usize,
    concat!("Size of: ", stringify!(nl_pktinfo))
  );
  assert_eq!(
    ::std::mem::align_of::<nl_pktinfo>(),
    4usize,
    concat!("Alignment of ", stringify!(nl_pktinfo))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_pktinfo>())).group as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_pktinfo),
      "::",
      stringify!(group)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_mmap_req {
  pub nm_block_size: ::std::os::raw::c_uint,
  pub nm_block_nr: ::std::os::raw::c_uint,
  pub nm_frame_size: ::std::os::raw::c_uint,
  pub nm_frame_nr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nl_mmap_req() {
  assert_eq!(
    ::std::mem::size_of::<nl_mmap_req>(),
    16usize,
    concat!("Size of: ", stringify!(nl_mmap_req))
  );
  assert_eq!(
    ::std::mem::align_of::<nl_mmap_req>(),
    4usize,
    concat!("Alignment of ", stringify!(nl_mmap_req))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_block_size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_mmap_req),
      "::",
      stringify!(nm_block_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_block_nr as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_mmap_req),
      "::",
      stringify!(nm_block_nr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_frame_size as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_mmap_req),
      "::",
      stringify!(nm_frame_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_frame_nr as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_mmap_req),
      "::",
      stringify!(nm_frame_nr)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_mmap_hdr {
  pub nm_status: ::std::os::raw::c_uint,
  pub nm_len: ::std::os::raw::c_uint,
  pub nm_group: __u32,
  pub nm_pid: __u32,
  pub nm_uid: __u32,
  pub nm_gid: __u32,
}
#[test]
fn bindgen_test_layout_nl_mmap_hdr() {
  assert_eq!(
    ::std::mem::size_of::<nl_mmap_hdr>(),
    24usize,
    concat!("Size of: ", stringify!(nl_mmap_hdr))
  );
  assert_eq!(
    ::std::mem::align_of::<nl_mmap_hdr>(),
    4usize,
    concat!("Alignment of ", stringify!(nl_mmap_hdr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_status as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_mmap_hdr),
      "::",
      stringify!(nm_status)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_len as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_mmap_hdr),
      "::",
      stringify!(nm_len)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_group as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_mmap_hdr),
      "::",
      stringify!(nm_group)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_pid as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_mmap_hdr),
      "::",
      stringify!(nm_pid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_uid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_mmap_hdr),
      "::",
      stringify!(nm_uid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_gid as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_mmap_hdr),
      "::",
      stringify!(nm_gid)
    )
  );
}
pub const nl_mmap_status_NL_MMAP_STATUS_UNUSED: nl_mmap_status = 0;
pub const nl_mmap_status_NL_MMAP_STATUS_RESERVED: nl_mmap_status = 1;
pub const nl_mmap_status_NL_MMAP_STATUS_VALID: nl_mmap_status = 2;
pub const nl_mmap_status_NL_MMAP_STATUS_COPY: nl_mmap_status = 3;
pub const nl_mmap_status_NL_MMAP_STATUS_SKIP: nl_mmap_status = 4;
pub type nl_mmap_status = u32;
pub const NETLINK_UNCONNECTED: _bindgen_ty_7 = 0;
pub const NETLINK_CONNECTED: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlattr {
  pub nla_len: __u16,
  pub nla_type: __u16,
}
#[test]
fn bindgen_test_layout_nlattr() {
  assert_eq!(
    ::std::mem::size_of::<nlattr>(),
    4usize,
    concat!("Size of: ", stringify!(nlattr))
  );
  assert_eq!(
    ::std::mem::align_of::<nlattr>(),
    2usize,
    concat!("Alignment of ", stringify!(nlattr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nlattr>())).nla_len as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(nlattr),
      "::",
      stringify!(nla_len)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nlattr>())).nla_type as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(nlattr),
      "::",
      stringify!(nla_type)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nla_bitfield32 {
  pub value: __u32,
  pub selector: __u32,
}
#[test]
fn bindgen_test_layout_nla_bitfield32() {
  assert_eq!(
    ::std::mem::size_of::<nla_bitfield32>(),
    8usize,
    concat!("Size of: ", stringify!(nla_bitfield32))
  );
  assert_eq!(
    ::std::mem::align_of::<nla_bitfield32>(),
    4usize,
    concat!("Alignment of ", stringify!(nla_bitfield32))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nla_bitfield32>())).value as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(nla_bitfield32),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nla_bitfield32>())).selector as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(nla_bitfield32),
      "::",
      stringify!(selector)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct genlmsghdr {
  pub cmd: __u8,
  pub version: __u8,
  pub reserved: __u16,
}
#[test]
fn bindgen_test_layout_genlmsghdr() {
  assert_eq!(
    ::std::mem::size_of::<genlmsghdr>(),
    4usize,
    concat!("Size of: ", stringify!(genlmsghdr))
  );
  assert_eq!(
    ::std::mem::align_of::<genlmsghdr>(),
    2usize,
    concat!("Alignment of ", stringify!(genlmsghdr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<genlmsghdr>())).cmd as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(genlmsghdr),
      "::",
      stringify!(cmd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<genlmsghdr>())).version as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(genlmsghdr),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<genlmsghdr>())).reserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(genlmsghdr),
      "::",
      stringify!(reserved)
    )
  );
}
extern "C" {
  #[link_name = "\u{1}nl_ver_num"]
  pub static nl_ver_num: ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}nl_ver_maj"]
  pub static nl_ver_maj: ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}nl_ver_min"]
  pub static nl_ver_min: ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}nl_ver_mic"]
  pub static nl_ver_mic: ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_geterror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_perror(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
  pub fn nl_syserr2nlerr(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = "< Dump object briefly on one line"]
pub const nl_dump_type_NL_DUMP_LINE: nl_dump_type = 0;
#[doc = "< Dump all attributes but no statistics"]
pub const nl_dump_type_NL_DUMP_DETAILS: nl_dump_type = 1;
#[doc = "< Dump all attributes including statistics"]
pub const nl_dump_type_NL_DUMP_STATS: nl_dump_type = 2;
pub const nl_dump_type___NL_DUMP_MAX: nl_dump_type = 3;
#[doc = " @ingroup utils"]
#[doc = " Enumeration of dumping variations (dp_type)"]
pub type nl_dump_type = u32;
#[doc = " @ingroup utils"]
#[doc = " Dumping parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_dump_params {
  #[doc = " Specifies the type of dump that is requested."]
  pub dp_type: nl_dump_type,
  #[doc = " Specifies the number of whitespaces to be put in front"]
  #[doc = " of every new line (indentation)."]
  pub dp_prefix: ::std::os::raw::c_int,
  #[doc = " Causes the cache index to be printed for each element."]
  pub dp_print_index: ::std::os::raw::c_int,
  #[doc = " Causes each element to be prefixed with the message type."]
  pub dp_dump_msgtype: ::std::os::raw::c_int,
  #[doc = " A callback invoked for output"]
  #[doc = ""]
  #[doc = " Passed arguments are:"]
  #[doc = "  - dumping parameters"]
  #[doc = "  - string to append to the output"]
  pub dp_cb: ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut nl_dump_params, arg2: *mut ::std::os::raw::c_char),
  >,
  #[doc = " A callback invoked for every new line, can be used to"]
  #[doc = " customize the indentation."]
  #[doc = ""]
  #[doc = " Passed arguments are:"]
  #[doc = "  - dumping parameters"]
  #[doc = "  - line number starting from 0"]
  pub dp_nl_cb: ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut nl_dump_params, arg2: ::std::os::raw::c_int),
  >,
  #[doc = " User data pointer, can be used to pass data to callbacks."]
  pub dp_data: *mut ::std::os::raw::c_void,
  #[doc = " File descriptor the dumping output should go to"]
  pub dp_fd: *mut FILE,
  #[doc = " Alternatively the output may be redirected into a buffer"]
  pub dp_buf: *mut ::std::os::raw::c_char,
  #[doc = " Length of the buffer dp_buf"]
  pub dp_buflen: usize,
  #[doc = " PRIVATE"]
  #[doc = " Set if a dump was performed prior to the actual dump handler."]
  pub dp_pre_dump: ::std::os::raw::c_int,
  #[doc = " PRIVATE"]
  #[doc = " Owned by the current caller"]
  pub dp_ivar: ::std::os::raw::c_int,
  pub dp_line: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nl_dump_params() {
  assert_eq!(
    ::std::mem::size_of::<nl_dump_params>(),
    80usize,
    concat!("Size of: ", stringify!(nl_dump_params))
  );
  assert_eq!(
    ::std::mem::align_of::<nl_dump_params>(),
    8usize,
    concat!("Alignment of ", stringify!(nl_dump_params))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_prefix as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_prefix)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_print_index as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_print_index)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_dump_msgtype as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_dump_msgtype)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_cb as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_nl_cb as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_nl_cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_data as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_fd as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_fd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_buf as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_buf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_buflen as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_buflen)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_pre_dump as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_pre_dump)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_ivar as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_ivar)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_line as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_dump_params),
      "::",
      stringify!(dp_line)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_cb {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_sock {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_msg {
  _unused: [u8; 0],
}
#[doc = " nl_recvmsgs() callback for message processing customization"]
#[doc = " @ingroup cb"]
#[doc = " @arg msg\t\tnetlink message being processed"]
#[doc = " @arg arg\t\targument passwd on through caller"]
pub type nl_recvmsg_msg_cb_t = ::std::option::Option<
  unsafe extern "C" fn(msg: *mut nl_msg, arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " nl_recvmsgs() callback for error message processing customization"]
#[doc = " @ingroup cb"]
#[doc = " @arg nla\t\tnetlink address of the peer"]
#[doc = " @arg nlerr\t\tnetlink error message being processed"]
#[doc = " @arg arg\t\targument passed on through caller"]
pub type nl_recvmsg_err_cb_t = ::std::option::Option<
  unsafe extern "C" fn(
    nla: *mut sockaddr_nl,
    nlerr: *mut nlmsgerr,
    arg: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int,
>;
#[doc = " Proceed with wathever would come next"]
pub const nl_cb_action_NL_OK: nl_cb_action = 0;
#[doc = " Skip this message"]
pub const nl_cb_action_NL_SKIP: nl_cb_action = 1;
#[doc = " Stop parsing altogether and discard remaining messages"]
pub const nl_cb_action_NL_STOP: nl_cb_action = 2;
#[doc = " Callback actions"]
#[doc = " @ingroup cb"]
pub type nl_cb_action = u32;
#[doc = " Default handlers (quiet)"]
pub const nl_cb_kind_NL_CB_DEFAULT: nl_cb_kind = 0;
#[doc = " Verbose default handlers (error messages printed)"]
pub const nl_cb_kind_NL_CB_VERBOSE: nl_cb_kind = 1;
#[doc = " Debug handlers for debugging"]
pub const nl_cb_kind_NL_CB_DEBUG: nl_cb_kind = 2;
#[doc = " Customized handler specified by the user"]
pub const nl_cb_kind_NL_CB_CUSTOM: nl_cb_kind = 3;
#[doc = " Customized handler specified by the user"]
pub const nl_cb_kind___NL_CB_KIND_MAX: nl_cb_kind = 4;
#[doc = " Callback kinds"]
#[doc = " @ingroup cb"]
pub type nl_cb_kind = u32;
#[doc = " Message is valid"]
pub const nl_cb_type_NL_CB_VALID: nl_cb_type = 0;
#[doc = " Last message in a series of multi part messages received"]
pub const nl_cb_type_NL_CB_FINISH: nl_cb_type = 1;
#[doc = " Report received that data was lost"]
pub const nl_cb_type_NL_CB_OVERRUN: nl_cb_type = 2;
#[doc = " Message wants to be skipped"]
pub const nl_cb_type_NL_CB_SKIPPED: nl_cb_type = 3;
#[doc = " Message is an acknowledge"]
pub const nl_cb_type_NL_CB_ACK: nl_cb_type = 4;
#[doc = " Called for every message received"]
pub const nl_cb_type_NL_CB_MSG_IN: nl_cb_type = 5;
#[doc = " Called for every message sent out except for nl_sendto()"]
pub const nl_cb_type_NL_CB_MSG_OUT: nl_cb_type = 6;
#[doc = " Message is malformed and invalid"]
pub const nl_cb_type_NL_CB_INVALID: nl_cb_type = 7;
#[doc = " Called instead of internal sequence number checking"]
pub const nl_cb_type_NL_CB_SEQ_CHECK: nl_cb_type = 8;
#[doc = " Sending of an acknowledge message has been requested"]
pub const nl_cb_type_NL_CB_SEND_ACK: nl_cb_type = 9;
#[doc = " Flag NLM_F_DUMP_INTR is set in message"]
pub const nl_cb_type_NL_CB_DUMP_INTR: nl_cb_type = 10;
#[doc = " Flag NLM_F_DUMP_INTR is set in message"]
pub const nl_cb_type___NL_CB_TYPE_MAX: nl_cb_type = 11;
#[doc = " Callback types"]
#[doc = " @ingroup cb"]
pub type nl_cb_type = u32;
extern "C" {
  pub fn nl_cb_alloc(arg1: nl_cb_kind) -> *mut nl_cb;
}
extern "C" {
  pub fn nl_cb_clone(arg1: *mut nl_cb) -> *mut nl_cb;
}
extern "C" {
  pub fn nl_cb_get(arg1: *mut nl_cb) -> *mut nl_cb;
}
extern "C" {
  pub fn nl_cb_put(arg1: *mut nl_cb);
}
extern "C" {
  pub fn nl_cb_set(
    arg1: *mut nl_cb,
    arg2: nl_cb_type,
    arg3: nl_cb_kind,
    arg4: nl_recvmsg_msg_cb_t,
    arg5: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_cb_set_all(
    arg1: *mut nl_cb,
    arg2: nl_cb_kind,
    arg3: nl_recvmsg_msg_cb_t,
    arg4: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_cb_err(
    arg1: *mut nl_cb,
    arg2: nl_cb_kind,
    arg3: nl_recvmsg_err_cb_t,
    arg4: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_cb_overwrite_recvmsgs(
    arg1: *mut nl_cb,
    func: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut nl_sock, arg2: *mut nl_cb) -> ::std::os::raw::c_int,
    >,
  );
}
extern "C" {
  pub fn nl_cb_overwrite_recv(
    arg1: *mut nl_cb,
    func: ::std::option::Option<
      unsafe extern "C" fn(
        arg1: *mut nl_sock,
        arg2: *mut sockaddr_nl,
        arg3: *mut *mut ::std::os::raw::c_uchar,
        arg4: *mut *mut ucred,
      ) -> ::std::os::raw::c_int,
    >,
  );
}
extern "C" {
  pub fn nl_cb_overwrite_send(
    arg1: *mut nl_cb,
    func: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut nl_sock, arg2: *mut nl_msg) -> ::std::os::raw::c_int,
    >,
  );
}
extern "C" {
  pub fn nl_cb_active_type(cb: *mut nl_cb) -> nl_cb_type;
}
extern "C" {
  pub fn nl_socket_alloc() -> *mut nl_sock;
}
extern "C" {
  pub fn nl_socket_alloc_cb(arg1: *mut nl_cb) -> *mut nl_sock;
}
extern "C" {
  pub fn nl_socket_free(arg1: *mut nl_sock);
}
extern "C" {
  pub fn nl_socket_get_local_port(arg1: *const nl_sock) -> u32;
}
extern "C" {
  pub fn nl_socket_set_local_port(arg1: *mut nl_sock, arg2: u32);
}
extern "C" {
  pub fn nl_socket_add_memberships(
    arg1: *mut nl_sock,
    arg2: ::std::os::raw::c_int,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_add_membership(
    arg1: *mut nl_sock,
    arg2: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_drop_memberships(
    arg1: *mut nl_sock,
    arg2: ::std::os::raw::c_int,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_drop_membership(
    arg1: *mut nl_sock,
    arg2: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_join_groups(arg1: *mut nl_sock, arg2: ::std::os::raw::c_int);
}
extern "C" {
  pub fn nl_socket_get_peer_port(arg1: *const nl_sock) -> u32;
}
extern "C" {
  pub fn nl_socket_set_peer_port(arg1: *mut nl_sock, arg2: u32);
}
extern "C" {
  pub fn nl_socket_get_peer_groups(sk: *const nl_sock) -> u32;
}
extern "C" {
  pub fn nl_socket_set_peer_groups(sk: *mut nl_sock, groups: u32);
}
extern "C" {
  pub fn nl_socket_get_cb(arg1: *const nl_sock) -> *mut nl_cb;
}
extern "C" {
  pub fn nl_socket_set_cb(arg1: *mut nl_sock, arg2: *mut nl_cb);
}
extern "C" {
  pub fn nl_socket_modify_cb(
    arg1: *mut nl_sock,
    arg2: nl_cb_type,
    arg3: nl_cb_kind,
    arg4: nl_recvmsg_msg_cb_t,
    arg5: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_modify_err_cb(
    arg1: *mut nl_sock,
    arg2: nl_cb_kind,
    arg3: nl_recvmsg_err_cb_t,
    arg4: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_set_buffer_size(
    arg1: *mut nl_sock,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_set_msg_buf_size(arg1: *mut nl_sock, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_get_msg_buf_size(arg1: *mut nl_sock) -> usize;
}
extern "C" {
  pub fn nl_socket_set_passcred(
    arg1: *mut nl_sock,
    arg2: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_recv_pktinfo(
    arg1: *mut nl_sock,
    arg2: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_disable_seq_check(arg1: *mut nl_sock);
}
extern "C" {
  pub fn nl_socket_use_seq(arg1: *mut nl_sock) -> ::std::os::raw::c_uint;
}
extern "C" {
  pub fn nl_socket_disable_auto_ack(arg1: *mut nl_sock);
}
extern "C" {
  pub fn nl_socket_enable_auto_ack(arg1: *mut nl_sock);
}
extern "C" {
  pub fn nl_socket_get_fd(arg1: *const nl_sock) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_set_fd(
    sk: *mut nl_sock,
    protocol: ::std::os::raw::c_int,
    fd: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_set_nonblocking(arg1: *const nl_sock) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_socket_enable_msg_peek(arg1: *mut nl_sock);
}
extern "C" {
  pub fn nl_socket_disable_msg_peek(arg1: *mut nl_sock);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_list_head {
  pub next: *mut nl_list_head,
  pub prev: *mut nl_list_head,
}
#[test]
fn bindgen_test_layout_nl_list_head() {
  assert_eq!(
    ::std::mem::size_of::<nl_list_head>(),
    16usize,
    concat!("Size of: ", stringify!(nl_list_head))
  );
  assert_eq!(
    ::std::mem::align_of::<nl_list_head>(),
    8usize,
    concat!("Alignment of ", stringify!(nl_list_head))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_list_head>())).next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_list_head),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nl_list_head>())).prev as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(nl_list_head),
      "::",
      stringify!(prev)
    )
  );
}
pub const NL_BYTE_RATE: _bindgen_ty_66 = 0;
pub const NL_BIT_RATE: _bindgen_ty_66 = 1;
#[doc = " @}"]
pub type _bindgen_ty_66 = u32;
extern "C" {
  pub fn nl_cancel_down_bytes(
    arg1: ::std::os::raw::c_ulonglong,
    arg2: *mut *mut ::std::os::raw::c_char,
  ) -> f64;
}
extern "C" {
  pub fn nl_cancel_down_bits(
    arg1: ::std::os::raw::c_ulonglong,
    arg2: *mut *mut ::std::os::raw::c_char,
  ) -> f64;
}
extern "C" {
  pub fn nl_rate2str(
    arg1: ::std::os::raw::c_ulonglong,
    arg2: ::std::os::raw::c_int,
    arg3: *mut ::std::os::raw::c_char,
    arg4: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_cancel_down_us(arg1: u32, arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
  pub fn nl_size2int(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn nl_size2str(
    arg1: usize,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_prob2int(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn nl_get_user_hz() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_get_psched_hz() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_us2ticks(arg1: u32) -> u32;
}
extern "C" {
  pub fn nl_ticks2us(arg1: u32) -> u32;
}
extern "C" {
  pub fn nl_str2msec(arg1: *const ::std::os::raw::c_char, arg2: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_msec2str(
    arg1: u64,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_llproto2str(
    arg1: ::std::os::raw::c_int,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_str2llproto(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_ether_proto2str(
    arg1: ::std::os::raw::c_int,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_str2ether_proto(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_ip_proto2str(
    arg1: ::std::os::raw::c_int,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_str2ip_proto(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_new_line(arg1: *mut nl_dump_params);
}
extern "C" {
  pub fn nl_dump(arg1: *mut nl_dump_params, arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
  pub fn nl_dump_line(arg1: *mut nl_dump_params, arg2: *const ::std::os::raw::c_char, ...);
}
pub const NL_CAPABILITY_NONE: _bindgen_ty_67 = 0;
#[doc = " rtnl_route_build_msg() no longer guesses the route scope"]
#[doc = " if explicitly set to RT_SCOPE_NOWHERE."]
#[doc = " @ingroup utils"]
pub const NL_CAPABILITY_ROUTE_BUILD_MSG_SET_SCOPE: _bindgen_ty_67 = 1;
#[doc = " rtnl_link_veth_get_peer() now returns a reference that is owned by the"]
#[doc = " caller and must be released by the caller with rtnl_link_put()."]
pub const NL_CAPABILITY_ROUTE_LINK_VETH_GET_PEER_OWN_REFERENCE: _bindgen_ty_67 = 2;
#[doc = " rtnl_u32_add_action() and rtnl_basic_add_action() now grab a reference to act"]
#[doc = " caller are free to release its own"]
pub const NL_CAPABILITY_ROUTE_LINK_CLS_ADD_ACT_OWN_REFERENCE: _bindgen_ty_67 = 3;
#[doc = " Indicate that the local port is unspecified until the user accesses"]
#[doc = " it (via nl_socket_get_local_port()) or until nl_connect(). More importantly,"]
#[doc = " if the port is left unspecified, nl_connect() will retry generating another"]
#[doc = " port when bind() fails with ADDRINUSE."]
pub const NL_CAPABILITY_NL_CONNECT_RETRY_GENERATE_PORT_ON_ADDRINUSE: _bindgen_ty_67 = 4;
#[doc = " Indicate that rtnl_link_get_kernel() fails with -NLE_OPNOTSUPP in case"]
#[doc = " of older kernals not supporting lookup by ifname. This changes behavior"]
#[doc = " from returning -NLE_INVAL to return -NLE_OPNOTSUPP."]
pub const NL_CAPABILITY_ROUTE_LINK_GET_KERNEL_FAIL_OPNOTSUPP: _bindgen_ty_67 = 5;
#[doc = " Also consider the a_cacheinfo field (ADDR_ATTR_CACHEINFO) that contains the"]
#[doc = " address timestamps and expiry when comparing struct rtnl_addr objects with"]
#[doc = " nl_object_diff()."]
pub const NL_CAPABILITY_ROUTE_ADDR_COMPARE_CACHEINFO: _bindgen_ty_67 = 6;
#[doc = " The library version is libnl3 3.2.26 or newer. This capability should never be backported."]
pub const NL_CAPABILITY_VERSION_3_2_26: _bindgen_ty_67 = 7;
#[doc = " nl_recv() fails with NLE_MSG_TRUNC if a message got truncated"]
#[doc = " with NL_MSG_PEEK disabled. Previously, the failed message was wrongly"]
#[doc = " discarded and the next message received."]
pub const NL_CAPABILITY_NL_RECV_FAIL_TRUNC_NO_PEEK: _bindgen_ty_67 = 8;
#[doc = " rtnl_link_build_change_request() and rtnl_link_change() would set ifi.ifi_flags but leave"]
#[doc = " ifi.ifi_change at zero. This was later fixed to set ifi.ifi_change to the flags that are actually"]
#[doc = " set in changes."]
pub const NL_CAPABILITY_LINK_BUILD_CHANGE_REQUEST_SET_CHANGE: _bindgen_ty_67 = 9;
#[doc = " Between 3.2.14 (64fcb47a36ec12d7e7f00605f6a8952ce985dd08) and 3.2.22 (8571f58f23763d8db7365d02c9b27832ad3d7005),"]
#[doc = " rtnl_neigh_get() behaved differently and only returned objects with family AF_UNSPEC."]
#[doc = " This capability indicates, that the function was fixed. The absense of the capability,"]
#[doc = " doesn\'t indicate however which behavior the function will have. So beware."]
pub const NL_CAPABILITY_RTNL_NEIGH_GET_FILTER_AF_UNSPEC_FIX: _bindgen_ty_67 = 10;
#[doc = " The library version is libnl3 3.2.27 or newer. This capability should never be backported."]
pub const NL_CAPABILITY_VERSION_3_2_27: _bindgen_ty_67 = 11;
#[doc = " Properly serialize vlan protocol IFLA_VLAN_PROTOCOL."]
pub const NL_CAPABILITY_RTNL_LINK_VLAN_PROTOCOL_SERIALZE: _bindgen_ty_67 = 12;
#[doc = " Properly read gre REMOTE port."]
pub const NL_CAPABILITY_RTNL_LINK_PARSE_GRE_REMOTE: _bindgen_ty_67 = 13;
#[doc = " Don\'t skip over vlan ingress-map entries with \"to\" field zero when serializing"]
#[doc = " a netlink message. Previously such entires would be ignored which inhibits the"]
#[doc = " user from clearing ingress map entries."]
pub const NL_CAPABILITY_RTNL_LINK_VLAN_INGRESS_MAP_CLEAR: _bindgen_ty_67 = 14;
#[doc = " Consider vxlan link info for nl_object_diff()."]
pub const NL_CAPABILITY_RTNL_LINK_VXLAN_IO_COMPARE: _bindgen_ty_67 = 15;
#[doc = " Support 64 bit attributes for nl_object_diff()."]
pub const NL_CAPABILITY_NL_OBJECT_DIFF64: _bindgen_ty_67 = 16;
#[doc = " Support omitting @key argument to xfrmnl_sa_get_*_params() to check"]
#[doc = " for required buffer size for key."]
pub const NL_CAPABILITY_XFRM_SA_KEY_SIZE: _bindgen_ty_67 = 17;
#[doc = " Properly handle nl_object_identity() for AF_INET and AF_INET6 addresses"]
#[doc = " and properly handle the peer/IFA_ADDRESS for IPv4 addresses."]
pub const NL_CAPABILITY_RTNL_ADDR_PEER_FIX: _bindgen_ty_67 = 18;
#[doc = " The library version is libnl3 3.2.28 or newer. This capability should never be backported."]
pub const NL_CAPABILITY_VERSION_3_2_28: _bindgen_ty_67 = 19;
#[doc = " After NL_CAPABILITY_RTNL_ADDR_PEER_FIX, a follow up regression to lookup"]
#[doc = " IPv4 addresses in the cache was fixed (PR#105)."]
pub const NL_CAPABILITY_RTNL_ADDR_PEER_ID_FIX: _bindgen_ty_67 = 20;
#[doc = " nl_addr_fill_sockaddr() properly checks that the provided address to"]
#[doc = " avoid read-out-of-bounds for invalid addresses."]
pub const NL_CAPABILITY_NL_ADDR_FILL_SOCKADDR: _bindgen_ty_67 = 21;
#[doc = " Support omitting @ctx_str argument to xfrmnl_sa_get_sec_ctx() to check"]
#[doc = " for required buffer size for context string."]
pub const NL_CAPABILITY_XFRM_SEC_CTX_LEN: _bindgen_ty_67 = 22;
#[doc = " rtnl_link_build_add_request() would set ifi.ifi_flags but leave ifi.ifi_change at zero."]
#[doc = " This was later fixed to set ifi.ifi_change to the flags that are actually"]
#[doc = " set"]
pub const NL_CAPABILITY_LINK_BUILD_ADD_REQUEST_SET_CHANGE: _bindgen_ty_67 = 23;
pub const NL_CAPABILITY_NL_RECVMSGS_PEEK_BY_DEFAULT: _bindgen_ty_67 = 24;
#[doc = " The library version is libnl3 3.2.29 or newer. This capability should never be backported."]
pub const NL_CAPABILITY_VERSION_3_2_29: _bindgen_ty_67 = 25;
#[doc = " Support omitting @ctx_str argument to xfrmnl_sp_get_sec_ctx() to check"]
#[doc = " for required buffer size for context string."]
pub const NL_CAPABILITY_XFRM_SP_SEC_CTX_LEN: _bindgen_ty_67 = 26;
#[doc = " The library version is libnl3 3.3.0 or newer. This capability should never be backported."]
pub const NL_CAPABILITY_VERSION_3_3_0: _bindgen_ty_67 = 27;
#[doc = " The library version is libnl3 3.4.0 or newer. This capability should never be backported."]
pub const NL_CAPABILITY_VERSION_3_4_0: _bindgen_ty_67 = 28;
pub const __NL_CAPABILITY_MAX: _bindgen_ty_67 = 29;
pub const NL_CAPABILITY_MAX: _bindgen_ty_67 = 28;
pub type _bindgen_ty_67 = u32;
extern "C" {
  pub fn nl_has_capability(capability: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_cache {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_object {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_object_ops {
  _unused: [u8; 0],
}
extern "C" {
  pub fn nl_object_alloc(arg1: *mut nl_object_ops) -> *mut nl_object;
}
extern "C" {
  pub fn nl_object_alloc_name(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut *mut nl_object,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_object_free(arg1: *mut nl_object);
}
extern "C" {
  pub fn nl_object_clone(obj: *mut nl_object) -> *mut nl_object;
}
extern "C" {
  pub fn nl_object_update(dst: *mut nl_object, src: *mut nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_object_get(arg1: *mut nl_object);
}
extern "C" {
  pub fn nl_object_put(arg1: *mut nl_object);
}
extern "C" {
  pub fn nl_object_shared(arg1: *mut nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_object_dump(arg1: *mut nl_object, arg2: *mut nl_dump_params);
}
extern "C" {
  pub fn nl_object_dump_buf(arg1: *mut nl_object, arg2: *mut ::std::os::raw::c_char, arg3: usize);
}
extern "C" {
  pub fn nl_object_identical(arg1: *mut nl_object, arg2: *mut nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_object_diff(arg1: *mut nl_object, arg2: *mut nl_object) -> u32;
}
extern "C" {
  pub fn nl_object_diff64(arg1: *mut nl_object, arg2: *mut nl_object) -> u64;
}
extern "C" {
  pub fn nl_object_match_filter(
    arg1: *mut nl_object,
    arg2: *mut nl_object,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_object_attrs2str(
    arg1: *mut nl_object,
    attrs: u32,
    buf: *mut ::std::os::raw::c_char,
    arg2: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_object_attr_list(
    arg1: *mut nl_object,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_object_keygen(arg1: *mut nl_object, arg2: *mut u32, arg3: u32);
}
extern "C" {
  pub fn nl_object_mark(arg1: *mut nl_object);
}
extern "C" {
  pub fn nl_object_unmark(arg1: *mut nl_object);
}
extern "C" {
  pub fn nl_object_is_marked(arg1: *mut nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_object_get_refcnt(arg1: *mut nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_object_get_cache(arg1: *mut nl_object) -> *mut nl_cache;
}
extern "C" {
  pub fn nl_object_get_type(arg1: *const nl_object) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_object_get_msgtype(arg1: *const nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_object_get_ops(arg1: *const nl_object) -> *mut nl_object_ops;
}
extern "C" {
  pub fn nl_object_get_id_attrs(obj: *mut nl_object) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_cache_ops {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_parser_param {
  _unused: [u8; 0],
}
extern "C" {
  #[link_name = "\u{1}nl_debug"]
  pub static mut nl_debug: ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}nl_debug_dp"]
  pub static mut nl_debug_dp: nl_dump_params;
}
extern "C" {
  pub fn nl_connect(arg1: *mut nl_sock, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_close(arg1: *mut nl_sock);
}
extern "C" {
  pub fn nl_sendto(
    arg1: *mut nl_sock,
    arg2: *mut ::std::os::raw::c_void,
    arg3: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_sendmsg(
    arg1: *mut nl_sock,
    arg2: *mut nl_msg,
    arg3: *mut msghdr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_send(arg1: *mut nl_sock, arg2: *mut nl_msg) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_send_iovec(
    arg1: *mut nl_sock,
    arg2: *mut nl_msg,
    arg3: *mut iovec,
    arg4: ::std::os::raw::c_uint,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_complete_msg(arg1: *mut nl_sock, arg2: *mut nl_msg);
}
extern "C" {
  pub fn nl_auto_complete(arg1: *mut nl_sock, arg2: *mut nl_msg);
}
extern "C" {
  pub fn nl_send_auto(arg1: *mut nl_sock, arg2: *mut nl_msg) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_send_auto_complete(arg1: *mut nl_sock, arg2: *mut nl_msg) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_send_sync(arg1: *mut nl_sock, arg2: *mut nl_msg) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_send_simple(
    arg1: *mut nl_sock,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
    arg4: *mut ::std::os::raw::c_void,
    arg5: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_recv(
    arg1: *mut nl_sock,
    arg2: *mut sockaddr_nl,
    arg3: *mut *mut ::std::os::raw::c_uchar,
    arg4: *mut *mut ucred,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_recvmsgs(arg1: *mut nl_sock, arg2: *mut nl_cb) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_recvmsgs_report(arg1: *mut nl_sock, arg2: *mut nl_cb) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_recvmsgs_default(arg1: *mut nl_sock) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_wait_for_ack(arg1: *mut nl_sock) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_pickup(
    arg1: *mut nl_sock,
    parser: ::std::option::Option<
      unsafe extern "C" fn(
        arg1: *mut nl_cache_ops,
        arg2: *mut sockaddr_nl,
        arg3: *mut nlmsghdr,
        arg4: *mut nl_parser_param,
      ) -> ::std::os::raw::c_int,
    >,
    arg2: *mut *mut nl_object,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_pickup_keep_syserr(
    sk: *mut nl_sock,
    parser: ::std::option::Option<
      unsafe extern "C" fn(
        arg1: *mut nl_cache_ops,
        arg2: *mut sockaddr_nl,
        arg3: *mut nlmsghdr,
        arg4: *mut nl_parser_param,
      ) -> ::std::os::raw::c_int,
    >,
    result: *mut *mut nl_object,
    syserror: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_nlfamily2str(
    arg1: ::std::os::raw::c_int,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_str2nlfamily(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_addr {
  _unused: [u8; 0],
}
extern "C" {
  pub fn nl_addr_alloc(arg1: usize) -> *mut nl_addr;
}
extern "C" {
  pub fn nl_addr_alloc_attr(arg1: *const nlattr, arg2: ::std::os::raw::c_int) -> *mut nl_addr;
}
extern "C" {
  pub fn nl_addr_build(
    arg1: ::std::os::raw::c_int,
    arg2: *const ::std::os::raw::c_void,
    arg3: usize,
  ) -> *mut nl_addr;
}
extern "C" {
  pub fn nl_addr_parse(
    arg1: *const ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
    arg3: *mut *mut nl_addr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_clone(arg1: *const nl_addr) -> *mut nl_addr;
}
extern "C" {
  pub fn nl_addr_get(arg1: *mut nl_addr) -> *mut nl_addr;
}
extern "C" {
  pub fn nl_addr_put(arg1: *mut nl_addr);
}
extern "C" {
  pub fn nl_addr_shared(arg1: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_cmp(arg1: *const nl_addr, arg2: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_cmp_prefix(arg1: *const nl_addr, arg2: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_iszero(arg1: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_valid(
    arg1: *const ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_guess_family(arg1: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_fill_sockaddr(
    arg1: *const nl_addr,
    arg2: *mut sockaddr,
    arg3: *mut socklen_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_info(arg1: *const nl_addr, arg2: *mut *mut addrinfo) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_resolve(
    arg1: *const nl_addr,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_set_family(arg1: *mut nl_addr, arg2: ::std::os::raw::c_int);
}
extern "C" {
  pub fn nl_addr_get_family(arg1: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_set_binary_addr(
    arg1: *mut nl_addr,
    arg2: *const ::std::os::raw::c_void,
    arg3: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr_get_binary_addr(arg1: *const nl_addr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn nl_addr_get_len(arg1: *const nl_addr) -> ::std::os::raw::c_uint;
}
extern "C" {
  pub fn nl_addr_set_prefixlen(arg1: *mut nl_addr, arg2: ::std::os::raw::c_int);
}
extern "C" {
  pub fn nl_addr_get_prefixlen(arg1: *const nl_addr) -> ::std::os::raw::c_uint;
}
extern "C" {
  pub fn nl_af2str(
    arg1: ::std::os::raw::c_int,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_str2af(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_addr2str(
    arg1: *const nl_addr,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_data {
  _unused: [u8; 0],
}
extern "C" {
  pub fn nl_data_alloc(arg1: *const ::std::os::raw::c_void, arg2: usize) -> *mut nl_data;
}
extern "C" {
  pub fn nl_data_alloc_attr(arg1: *const nlattr) -> *mut nl_data;
}
extern "C" {
  pub fn nl_data_clone(arg1: *const nl_data) -> *mut nl_data;
}
extern "C" {
  pub fn nl_data_append(
    arg1: *mut nl_data,
    arg2: *const ::std::os::raw::c_void,
    arg3: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_data_free(arg1: *mut nl_data);
}
extern "C" {
  pub fn nl_data_get(arg1: *const nl_data) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn nl_data_get_size(arg1: *const nl_data) -> usize;
}
extern "C" {
  pub fn nl_data_cmp(arg1: *const nl_data, arg2: *const nl_data) -> ::std::os::raw::c_int;
}
#[doc = "< Unspecified type, binary data chunk"]
pub const NLA_UNSPEC: _bindgen_ty_68 = 0;
#[doc = "< 8 bit integer"]
pub const NLA_U8: _bindgen_ty_68 = 1;
#[doc = "< 16 bit integer"]
pub const NLA_U16: _bindgen_ty_68 = 2;
#[doc = "< 32 bit integer"]
pub const NLA_U32: _bindgen_ty_68 = 3;
#[doc = "< 64 bit integer"]
pub const NLA_U64: _bindgen_ty_68 = 4;
#[doc = "< NUL terminated character string"]
pub const NLA_STRING: _bindgen_ty_68 = 5;
#[doc = "< Flag"]
pub const NLA_FLAG: _bindgen_ty_68 = 6;
#[doc = "< Micro seconds (64bit)"]
pub const NLA_MSECS: _bindgen_ty_68 = 7;
#[doc = "< Nested attributes"]
pub const NLA_NESTED: _bindgen_ty_68 = 8;
pub const NLA_NESTED_COMPAT: _bindgen_ty_68 = 9;
pub const NLA_NUL_STRING: _bindgen_ty_68 = 10;
pub const NLA_BINARY: _bindgen_ty_68 = 11;
pub const NLA_S8: _bindgen_ty_68 = 12;
pub const NLA_S16: _bindgen_ty_68 = 13;
pub const NLA_S32: _bindgen_ty_68 = 14;
pub const NLA_S64: _bindgen_ty_68 = 15;
pub const __NLA_TYPE_MAX: _bindgen_ty_68 = 16;
#[doc = " @ingroup attr"]
#[doc = " Basic attribute data types"]
#[doc = ""]
#[doc = " See section @core_doc{core_attr_parse,Attribute Parsing} for more details."]
pub type _bindgen_ty_68 = u32;
#[doc = " @ingroup attr"]
#[doc = " Attribute validation policy."]
#[doc = ""]
#[doc = " See section @core_doc{core_attr_parse,Attribute Parsing} for more details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nla_policy {
  #[doc = " Type of attribute or NLA_UNSPEC"]
  pub type_: u16,
  #[doc = " Minimal length of payload required"]
  pub minlen: u16,
  #[doc = " Maximal length of payload allowed"]
  pub maxlen: u16,
}
#[test]
fn bindgen_test_layout_nla_policy() {
  assert_eq!(
    ::std::mem::size_of::<nla_policy>(),
    6usize,
    concat!("Size of: ", stringify!(nla_policy))
  );
  assert_eq!(
    ::std::mem::align_of::<nla_policy>(),
    2usize,
    concat!("Alignment of ", stringify!(nla_policy))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nla_policy>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(nla_policy),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nla_policy>())).minlen as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(nla_policy),
      "::",
      stringify!(minlen)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<nla_policy>())).maxlen as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(nla_policy),
      "::",
      stringify!(maxlen)
    )
  );
}
extern "C" {
  pub fn nla_attr_size(payload: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_total_size(payload: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_padlen(payload: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_type(arg1: *const nlattr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_data(arg1: *const nlattr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn nla_len(arg1: *const nlattr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_ok(arg1: *const nlattr, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_next(arg1: *const nlattr, arg2: *mut ::std::os::raw::c_int) -> *mut nlattr;
}
extern "C" {
  pub fn nla_parse(
    arg1: *mut *mut nlattr,
    arg2: ::std::os::raw::c_int,
    arg3: *mut nlattr,
    arg4: ::std::os::raw::c_int,
    arg5: *mut nla_policy,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_validate(
    arg1: *const nlattr,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
    arg4: *const nla_policy,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_find(
    arg1: *const nlattr,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
  ) -> *mut nlattr;
}
extern "C" {
  pub fn nla_memcpy(
    arg1: *mut ::std::os::raw::c_void,
    arg2: *const nlattr,
    arg3: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_strlcpy(arg1: *mut ::std::os::raw::c_char, arg2: *const nlattr, arg3: usize) -> usize;
}
extern "C" {
  pub fn nla_memcmp(
    arg1: *const nlattr,
    arg2: *const ::std::os::raw::c_void,
    arg3: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_strcmp(
    arg1: *const nlattr,
    arg2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_reserve(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
  ) -> *mut nlattr;
}
extern "C" {
  pub fn nla_put(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
    arg4: *const ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_put_data(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: *const nl_data,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_put_addr(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: *mut nl_addr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_get_s8(arg1: *const nlattr) -> i8;
}
extern "C" {
  pub fn nla_put_s8(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: i8,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_get_u8(arg1: *const nlattr) -> u8;
}
extern "C" {
  pub fn nla_put_u8(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: u8,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_get_s16(arg1: *const nlattr) -> i16;
}
extern "C" {
  pub fn nla_put_s16(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: i16,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_get_u16(arg1: *const nlattr) -> u16;
}
extern "C" {
  pub fn nla_put_u16(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: u16,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_get_s32(arg1: *const nlattr) -> i32;
}
extern "C" {
  pub fn nla_put_s32(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: i32,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_get_u32(arg1: *const nlattr) -> u32;
}
extern "C" {
  pub fn nla_put_u32(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: u32,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_get_s64(arg1: *const nlattr) -> i64;
}
extern "C" {
  pub fn nla_put_s64(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: i64,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_get_u64(arg1: *const nlattr) -> u64;
}
extern "C" {
  pub fn nla_put_u64(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: u64,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_get_string(arg1: *const nlattr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nla_strdup(arg1: *const nlattr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nla_put_string(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_get_flag(arg1: *const nlattr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_put_flag(arg1: *mut nl_msg, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_get_msecs(arg1: *const nlattr) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn nla_put_msecs(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_put_nested(
    arg1: *mut nl_msg,
    arg2: ::std::os::raw::c_int,
    arg3: *const nl_msg,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_nest_start(arg1: *mut nl_msg, arg2: ::std::os::raw::c_int) -> *mut nlattr;
}
extern "C" {
  pub fn nla_nest_end(arg1: *mut nl_msg, arg2: *mut nlattr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_nest_cancel(arg1: *mut nl_msg, arg2: *const nlattr);
}
extern "C" {
  pub fn nla_parse_nested(
    arg1: *mut *mut nlattr,
    arg2: ::std::os::raw::c_int,
    arg3: *mut nlattr,
    arg4: *mut nla_policy,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nla_is_nested(arg1: *const nlattr) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_tree {
  _unused: [u8; 0],
}
extern "C" {
  pub fn nlmsg_size(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_total_size(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_padlen(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_data(arg1: *const nlmsghdr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn nlmsg_datalen(arg1: *const nlmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_tail(arg1: *const nlmsghdr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn nlmsg_attrdata(arg1: *const nlmsghdr, arg2: ::std::os::raw::c_int) -> *mut nlattr;
}
extern "C" {
  pub fn nlmsg_attrlen(arg1: *const nlmsghdr, arg2: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_valid_hdr(
    arg1: *const nlmsghdr,
    arg2: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_ok(arg1: *const nlmsghdr, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_next(arg1: *mut nlmsghdr, arg2: *mut ::std::os::raw::c_int) -> *mut nlmsghdr;
}
extern "C" {
  pub fn nlmsg_parse(
    arg1: *mut nlmsghdr,
    arg2: ::std::os::raw::c_int,
    arg3: *mut *mut nlattr,
    arg4: ::std::os::raw::c_int,
    arg5: *mut nla_policy,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_find_attr(
    arg1: *mut nlmsghdr,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
  ) -> *mut nlattr;
}
extern "C" {
  pub fn nlmsg_validate(
    arg1: *mut nlmsghdr,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
    arg4: *mut nla_policy,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_alloc() -> *mut nl_msg;
}
extern "C" {
  pub fn nlmsg_alloc_size(arg1: usize) -> *mut nl_msg;
}
extern "C" {
  pub fn nlmsg_alloc_simple(
    arg1: ::std::os::raw::c_int,
    arg2: ::std::os::raw::c_int,
  ) -> *mut nl_msg;
}
extern "C" {
  pub fn nlmsg_set_default_size(arg1: usize);
}
extern "C" {
  pub fn nlmsg_inherit(arg1: *mut nlmsghdr) -> *mut nl_msg;
}
extern "C" {
  pub fn nlmsg_convert(arg1: *mut nlmsghdr) -> *mut nl_msg;
}
extern "C" {
  pub fn nlmsg_reserve(
    arg1: *mut nl_msg,
    arg2: usize,
    arg3: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn nlmsg_append(
    arg1: *mut nl_msg,
    arg2: *mut ::std::os::raw::c_void,
    arg3: usize,
    arg4: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_expand(arg1: *mut nl_msg, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_put(
    arg1: *mut nl_msg,
    arg2: u32,
    arg3: u32,
    arg4: ::std::os::raw::c_int,
    arg5: ::std::os::raw::c_int,
    arg6: ::std::os::raw::c_int,
  ) -> *mut nlmsghdr;
}
extern "C" {
  pub fn nlmsg_hdr(arg1: *mut nl_msg) -> *mut nlmsghdr;
}
extern "C" {
  pub fn nlmsg_get(arg1: *mut nl_msg);
}
extern "C" {
  pub fn nlmsg_free(arg1: *mut nl_msg);
}
extern "C" {
  pub fn nlmsg_set_proto(arg1: *mut nl_msg, arg2: ::std::os::raw::c_int);
}
extern "C" {
  pub fn nlmsg_get_proto(arg1: *mut nl_msg) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nlmsg_get_max_size(arg1: *mut nl_msg) -> usize;
}
extern "C" {
  pub fn nlmsg_set_src(arg1: *mut nl_msg, arg2: *mut sockaddr_nl);
}
extern "C" {
  pub fn nlmsg_get_src(arg1: *mut nl_msg) -> *mut sockaddr_nl;
}
extern "C" {
  pub fn nlmsg_set_dst(arg1: *mut nl_msg, arg2: *mut sockaddr_nl);
}
extern "C" {
  pub fn nlmsg_get_dst(arg1: *mut nl_msg) -> *mut sockaddr_nl;
}
extern "C" {
  pub fn nlmsg_set_creds(arg1: *mut nl_msg, arg2: *mut ucred);
}
extern "C" {
  pub fn nlmsg_get_creds(arg1: *mut nl_msg) -> *mut ucred;
}
extern "C" {
  pub fn nl_nlmsgtype2str(
    arg1: ::std::os::raw::c_int,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_str2nlmsgtype(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_nlmsg_flags2str(
    arg1: ::std::os::raw::c_int,
    arg2: *mut ::std::os::raw::c_char,
    arg3: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn nl_msg_parse(
    arg1: *mut nl_msg,
    cb: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut nl_object, arg2: *mut ::std::os::raw::c_void),
    >,
    arg2: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nl_msg_dump(arg1: *mut nl_msg, arg2: *mut FILE);
}
extern "C" {
  pub fn genl_connect(arg1: *mut nl_sock) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn genl_send_simple(
    arg1: *mut nl_sock,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_int,
    arg5: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn genlmsg_put(
    arg1: *mut nl_msg,
    arg2: u32,
    arg3: u32,
    arg4: ::std::os::raw::c_int,
    arg5: ::std::os::raw::c_int,
    arg6: ::std::os::raw::c_int,
    arg7: u8,
    arg8: u8,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn genlmsg_valid_hdr(
    arg1: *mut nlmsghdr,
    arg2: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn genlmsg_validate(
    arg1: *mut nlmsghdr,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
    arg4: *mut nla_policy,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn genlmsg_parse(
    arg1: *mut nlmsghdr,
    arg2: ::std::os::raw::c_int,
    arg3: *mut *mut nlattr,
    arg4: ::std::os::raw::c_int,
    arg5: *mut nla_policy,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn genlmsg_hdr(arg1: *mut nlmsghdr) -> *mut genlmsghdr;
}
extern "C" {
  pub fn genlmsg_data(arg1: *const genlmsghdr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn genlmsg_user_hdr(arg1: *const genlmsghdr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn genlmsg_user_data(
    arg1: *const genlmsghdr,
    arg2: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn genlmsg_user_datalen(
    arg1: *const genlmsghdr,
    arg2: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn genlmsg_len(arg1: *const genlmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn genlmsg_attrdata(arg1: *const genlmsghdr, arg2: ::std::os::raw::c_int) -> *mut nlattr;
}
extern "C" {
  pub fn genlmsg_attrlen(
    arg1: *const genlmsghdr,
    arg2: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn genl_op2name(
    arg1: ::std::os::raw::c_int,
    arg2: ::std::os::raw::c_int,
    arg3: *mut ::std::os::raw::c_char,
    arg4: usize,
  ) -> *mut ::std::os::raw::c_char;
}
